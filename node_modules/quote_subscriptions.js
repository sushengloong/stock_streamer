////////////////////////////////////////////////////////////////////////////////////////////
//
// This module maintains quote subscriptions for all clients
//
////////////////////////////////////////////////////////////////////////////////////////////
var yclient = require('y_client');
var stocksSubscribers = {};
var quoteCache = {};
exports.subscribe = function(socket, symbol, callback) {
   if (typeof socket.stockSymbols === "undefined") {
      socket.stockSymbols = [];
   }
   if (socket.stockSymbols.indexOf(symbol) == -1) {
      socket.stockSymbols.push(symbol);
   }
   //
   var subscribers = stocksSubscribers[symbol];
   if (typeof subscribers === "undefined") {
      subscribers = [];
      stocksSubscribers[symbol] = subscribers;
   }
   if (subscribers.indexOf(socket) == -1) {
      subscribers.push(socket);
   }
   callback();
}
 
exports.unsubscribeAll = function(socket, callback) {
   if (typeof socket.stockSymbols === "undefined") {
      return;
   }
   for (var i=0; i<socket.stockSymbols.length; i++) {
      this.unsubscribe(socket, socket.stockSymbols[i], function() {});
   }
   callback();
}
 
exports.unsubscribe = function(socket, symbol, callback) {
   if (typeof socket.stockSymbols === "undefined") {
      return;
   }
   var ndx = socket.stockSymbols.indexOf(symbol);
   if (ndx !== -1) {
      socket.stockSymbols.splice(ndx, 1);
   }
   //
   var subscribers = stocksSubscribers[symbol];
   if (typeof subscribers === "undefined") {
      return;
   }
   ndx = subscribers.indexOf(socket);
   if (ndx !== -1) {
      subscribers.splice(ndx, 1);
   }
   callback();
}
exports.pushUpdates = function() {
   for (var symbol in stocksSubscribers) {
      var sockets = stocksSubscribers[symbol];
      if (sockets.length == 0) {
         continue;
      }
      quote = quoteCache[symbol];
      if (typeof quote === "undefined") {
         yclient.quote(symbol, function(quote) {
            quoteCache[symbol] = quote;
            sendQuote(quote, sockets);
         });
      } else {
         sendQuote(quote, sockets);
      }
   }
}
 
function sendQuote(quote, sockets) {
   var rnd = Math.random();
   quote.counter = quote.counter + 1;
   quote.bid = round(rnd % 2 == 0 ? quote.original_bid + rnd :  quote.original_bid - rnd, 2);
   quote.ask = round(rnd % 2 == 0 ? quote.original_ask + rnd :  quote.original_ask - rnd, 2);
   for (var i=0; i<sockets.length; i++) {
      var socket = sockets[i];
      var address = socket.handshake.address;
      console.log('Quote sending ' + quote.symbol + ' ' + quote.counter + ' to ' + address.address + ":" + address.port);
      socket.volatile.emit('receive-stock-quote', quote);
   }
}
 
function round(num, dec) {
   return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
}
